COMMON LISP
* Objectives

The purpose of this tutorial is to give you the eureka that lisp
users talk about.  This should be done with the least amount of
ceremony.   This tutorial is targetted at programmers who know some
other languages, like java, etc...

You can get a hint of what this 'lisp elightenment' by reading:  [[http://www.defmacro.org/ramblings/lisp.html][The
Nature of Lisp]].  Or you can read the first chapter in: [[http://www.gigamonkeys.com/book/introduction-why-lisp.html][Practical
Common Lisp]].  To paraphrase:

* Endorsements

"If you think the greatest pleasure in programming comes from getting a
lot done with code that simply and clearly expresses your intention,
then programming in Common Lisp is likely to be about the most fun you
can have with a computer. You'll get more done, faster, using it than
you would using pretty much any other language." -- Peter Seibel


"Many extremely intelligent people I knew and had much respect for
were praising Lisp with almost religious dedication. There had to be
something there, something I couldn't afford not to get my hands on!
Eventually my thirst for knowledge won me over [...] The enlightenment
came instantaneously. One moment I understood nothing, and the next
moment everything clicked into place. I've achieved nirvana. Dozens of
times I heard Eric Raymond's statement quoted by different people:
"Lisp is worth learning for the profound enlightenment experience you
will have when you finally get it; that experience will make you a
better programmer for the rest of your days, even if you never
actually use Lisp itself a lot." I never understood this statement. I
never believed it could be true. And finally, after all the pain, it
made sense! There was more truth to it than I ever could have
imagined. I've achieved an almost divine state of mind, an
instantaneous enlightenment experience that turned my view of computer
science on its head in less than a single second." -- from: The
Nature of Lisp

* Method

This tutorial will assume you have emacs running on your computer.
Many will argue this isn't a good start as it's trying to kill two
birds with one stone.  My counter argument is that if you want to
know lisp, you'll need to have an editor, and Emacs is arguably one
of the best editors for lisp, being that it itself is written and
extended in a lisp.

* The Basics

This section will go over the bare bones of lisp.  In one of your
emacs buffers put the following line:

    (setq myvar "Hello World")

put the cursor after the last param and type

    C-x C-e

which means hold down the Ctrl key and press x, then e.  You have
just created a variable `myvar` and gave it the string value: `Hello
World`.  Add the following line:

    (message myvar)

and evaluate it again with C-x C-e.  You should see "Hello World"
appear in the mini-buffer.

Now go read the following: [[file:lisp-basics.org][Lisp Basics]], it comes from The Nature of
Lisp article, so no need to repeat it.

* Projects

** Todo List

    '(:description "Buy Milk" :location "7-Eleven" :due-by "02-15-2013")

Lets set this to a variable:

    (setq todo1 '(:description "Buy Milk" :location "7-Eleven" :due-by
    "02-15-2013"))

Okay, lets grab the due-by date:

    (getf todo1 :due-by)

Lets create a second task:

    (setq todo2 '(:description "Take out garbage" :location "Home" :due-by
    "02-14-2013"))

Now we want to create a list of all of our todos:

    (setq todos (list todo1 todo2))

So now `todos` is a list of lists or a list of plists.  Lets create a
function to get the description:

    (defun get-description (prop-list)
      (getf prop-list :description))

Now lets use this function to pull out all the descriptions:

    (mapcar 'get-description todos)

Lets persist our 'database' of todos:

* Debugger

Hit `RET` on any line of stack to get more info.

* Macros

A back quote (`) before an expression stops evaluation just like a
forward quote.  

in a back-quoted expression, any subexpression that’s
preceded by a comma is evaluated.

    `(1 2 ,(+ 1 2)) => (1 2 3)

* Functions
** Higher Order

Must use `funcall` to call the function

    (defun add-one (a) (+ 1 a))
    (defun user-func (fn b) (funcall fn b)) 
    (user-func #'add-one 10) => 11

** Strings

CONCATENATE creates new sequence and fills it with data from arguments. See also MAPCAN.

    (concatenate 'string "hello" " " "world") => "hello world"
    (concatenate 'list "hello" " " "world") => (#\h #\e #\l #\l #\o #\  #\w #\o #\r #\l #\d)
    (concatenate 'vector "hello" " " "world") => #(#\h #\e #\l #\l #\o #\  #\w #\o #\r #\l #\d)
    (concatenate 'vector '(1 2) '(3 4)) => #(1 2 3 4)

** plist

GETF searches supplied plist for value with matching key

    (setf plist '(:name "Fenton" :age "10"))
    (getf plist :name) => "Fenton"

LET local variable binding

    (let ((x 10) (y 20) z) ...)

nice ref: http://jtra.cz/stuff/lisp/sclr/index.html

|-------------+-------------------------------------------------|
| function    | purpose                                         |
|-------------+-------------------------------------------------|
| apply       | call supplied function with specified arguments |
| concatenate | like append but creates new list                |
| append      | concatenates list arguments into one list       |
| assoc       | find element in alist                           |
|-------------+-------------------------------------------------|

* Priting
  
** FORMAT

    format destination control-string args(zero or more) => string or NIL

    (setf x 10)
    (format t "~d " x)

t is output.  ~d is integer

~a - output with aesthetics
~s - standard output
~% newline
tilde parenthesis - flow control
tilde tilde - escape sequence for tilde

    (format nil "Items in list:~%~{~a, ~}" '(1 2 3 4)) => "Items in list:
    1, 2, 3, 4, "
    (format nil "~{~a~^, ~}" '(1 2 3 4)) => "1, 2, 3, 4"
    (format nil "~f" 3.141592) => "3.141592"
    (format nil "~2,3f" 3.141592) => "3.142"
    (format nil "~7,3f" 3.141592) => "  3.142"
    (format nil "~a ~s" "xyz" "xyz") => "xyz \"xyz\""

* Loops

** DOTIMES

    (dotimes (x 10) (format t "~d " x))

** LOOP

Vectors: for x across vector

```
(with-output-to-string 
  (final-string)
  (loop
   for curr-element across my-sequence
   do (write-string curr-element final-string)))
```

Looping putting output into `final-string`.  Loop over
`my-sequence`.  Each element goes into: `curr-element`

Lists: for x in list

* Setup Environment

** Connect from Emacs

    A-x slime-connect

** Sample .emacs

(eval-after-load “slime”
‘(progn
(setq slime-lisp-implementations
‘((sbcl (“/usr/bin/sbcl”))
(clisp (“/usr/bin/clisp”)))
common-lisp-hyperspec-root “/home/sujoy/documents/hyperspec/”)
(slime-setup ‘(slime-asdf
slime-autodoc
slime-editing-commands
slime-fancy-inspector
slime-fontifying-fu
slime-fuzzy
slime-indentation
slime-mdot-fu
slime-package-fu
slime-references
slime-repl
slime-sbcl-exts
slime-scratch
slime-xref-browser))
(slime-autodoc-mode)
(setq slime-complete-symbol*-fancy t)
(setq slime-complete-symbol-function ‘slime-fuzzy-complete-symbol)
(add-hook ‘lisp-mode-hook (lambda () (slime-mode t)))))

(require ‘slime)

** Quicklisp

Install/Setup quicklisp: http://www.quicklisp.org

    (ql:quickload "pkg")

quickload will download the package if it doesn't have it, and then
it will load the system, using asdf.

|-----------------------------------+-----------------------------------------------------|
| command                           | effect                                              |
|-----------------------------------+-----------------------------------------------------|
| (ql:quickload "swank")            | install swank into sbcl                             |
| (ql:system-apropos "some-string") | search for package: "some-string" in quicklist repo |
|-----------------------------------+-----------------------------------------------------|

** Swank on SBCL

add following into: `~/.sbclrc` to start swank on sbcl startup.

    (ql:quickload "swank")
    (swank:create-server)

fire up sbcl

    $ sbcl

swank will now be running in sbcl and you can connect to it from
emacs. 

** SBCL

Download and install SBCL via pacman

    $ sudo pacman -S sbcl

in `~/.sbclrc` put:

    (require :asdf)

* REPL

| key   | effect                         |
|-------+--------------------------------|
| A-C-x | Evaluate current toplevel form |
|       |                                |

* Tutorial

A variable

```
CL-USER> (defparameter my-age 19)
MY-AGE
CL-USER> my-age
19
```

Redefine the variable:

```
CL-USER> (defparameter my-age 20)
MY-AGE
CL-USER> my-age
20
```

* System (package) Management ASDF
** Defining a System
*** Basics

Say you have a project with name:

    body-parts

Put that in a folder called `body-parts`, with a file at the top level
called: 

    body-parts/body-parts.asd

in `body-parts.asd`, at the top, as usual, put:

```
(defpackage #:body-parts
  (:use :cl :asdf))
(in-package :body-parts)
```

then the asdf specific part after that is:

```
(defsystem body-parts
  :name "body-parts"
  :version "0.0.0"
  :maintainer "T. God"
  :author "Desmon Table"
  :licence "BSD sans advertising clause (see file COPYING for details)"
  :description "Body-Parts"
  :long-description "Lisp implementation of the body."
```

only `:name` is required, the others are optional.

*** Specify Dependencies
**** Simple

The simplest case is when your dependencies are linear.  For example: 

`head.lisp` depends on `torso.lisp` depends on `legs.lisp`

In the asdf file this is specified like so:

```
:components ((:file "legs")
             (:file "torso" :depends-on ("legs"))
             (:file "head" :depends-on ("torso")))
```

`torso` depends on legs, and `head` depends on `torso` and hence
transitively on `legs`.

So the whole file at this point looks like this:

```
(defpackage #:body-parts
  (:use :cl :asdf))
(in-package :body-parts)
(defsystem body-parts
  :name "body-parts"
  :version "0.0.0"
  :components ((:file "legs")
               (:file "torso" :depends-on ("legs"))
               (:file "head" :depends-on ("torso"))))
```

i dropped the optional parts of the `defsystem` form for brevity, the
folder would look like:

```
body-parts/
|-- body-parts.asd
|-- head.lisp
|-- legs.lisp
`-- torso.lisp
```

**** Sub-Systems / Modules

A subsytem, or module, will be a sub-folder of `body-parts`, lets call
it `art`, and put the files `tattoo.lisp` and `ink.lisp` in
there.

The folder tree looks like:

```
body-parts/
|-- art
|   |-- ink.lisp
|   `-- tattoo.lisp
|-- body-parts.asd
|-- head.lisp
|-- legs.lisp
`-- torso.lisp
```

we add the following to the defsystem form:

(:module circulation
   :components ((:file "ink")
                (:file "tattoo" :depends-on "ink")))

So the file with a bit more context looks like:

```
(defsystem body-parts
  :name "body-parts"
  :version "0.0.0"
  :components ((:file "legs")
               (:file "torso" :depends-on ("legs"))
               (:file "head" :depends-on ("torso"))
               (:module circulation
                  :components ((:file "ink")
                               (:file "tattoo" :depends-on "ink")))))
```

NOTE: It is important to note that dependencies can only be defined
inside a given set of components. So, the file `torso.lisp` cannot
depend on the file `ink.lisp`, which is a component of a submodule.

**** Depending on another System

Just add a `:depends-on` parameter to the defsystem form.

(defsystem body-parts
  ;;; ...
  :components (...)
  :depends-on ("other-system"))

** Using a System

So in our `~/.sbclrc` file we'd put:

```
(require :asdf)
(push "/home/fenton/projects/lisp/systems/" asdf:*central-registry*)
```
In the previous section we created a system called `body-parts`, lets
say our folder system looks like this:

```
/home/
`-- fenton/
    `-- projects/
        `-- lisp/
            |-- body-parts/
            `-- systems/
```

We simply create a symbolic link to `body-parts.asd` in
`/home/fenton/projects/lisp/systems`:

```
$ cd /home/fenton/projects/systems
$ ln -s /home/fenton/projects/body-parts/body-parts.asd
```

and then in SBCl we can load the `body-parts` project with:

(asdf:operate 'asdf:load-op 'body-parts)

** References

[[http://common-lisp.net/~mmommer/asdf-howto.shtml][Getting Started with ASDF]]

* packages
** overview
    package:symbol-name

single colon `:` will access only symbols that the package author has
externalized.  

    package::symbol-name

access NON externalized symbols.  BAD idea normally.

    (find-package "pkg-name")

to get a specified package

    *PACKAGE*

a synonym for the CURRENT package

    (find-symbol "symbol-name")
    (intern "symbol-name")

`intern` like `find-symbol` except if not found creates (intern)
`symbol-name` 

    #:symbol-name

similar to regular keywords, except NOT intened in the KEYWORDS
package. 

    :use "package-name"

When I `use` another package, I inherit all it's `external` symbols.
Symbols are made external by `exporting` them.

    importing

you can import a symbol without using it's home package, thereby
adding that symbol into your name-to-symbol table.

** find all symbols

(do-external-symbols (s (find-package "PACKAGE"))
  (print s))

* Web - Hunchentoot
** references 

Two great articles:

http://www.adampetersen.se/articles/lispweb.htm

and

http://msnyder.info/posts/2011/07/lisp-for-the-web-part-ii/

** Install / Setup

I'll abbreviate Hutchentoot to just H.

To install H., just do the following once:

    (ql:quickload "hunchentoot")

To start the server:

    (hunchentoot:start (make-instance 'hunchentoot:easy-acceptor :port 4242))

Test it out in a browser:

    http://127.0.0.1:4242/

** Routing

now we want to route certain URLs to create different pages.  H. has
a global variable:

    *dispatch-table*

that contains a `list` dispatch routes.  Example:

```
(defun ctrlr-index () "this is the index")
(defun ctrlr-about () "this is the about")
(setq *dispatch-table*
 (list
  (create-regex-dispatcher "^/index" 'controller-index)
  (create-regex-dispatcher "^/about" 'controller-about)))
```

So any url with `/index` after the machine name, will execute the `controller
** URL Params
** Templating cl-who

    (ql:quickload "cl-who")

(defpackage #:my-package
  (:use :cl :asdf :cl-who))


```
(defun ctrlr-index () 
  (with-html-output-to-string
      (*standard-output* nil :prologue t)
    (:html
     (:head (:title "Hello, world!"))
     (:body
      (:h1 "Hello, world!")
      (:p "This is my Lisp web server, running on Hunchentoot,"
          " as described in "
          (:a :href
              "http://newartisans.com/blog_files/hunchentoot.primer.php"
              "this blog entry")
          " on Common Lisp and Hunchentoot.")))))
```


* Git Prompt

Enable vcs_info and call it in a pre-command:

```
autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git
precmd() {
    vcs_info
}
setopt prompt_subst
```

Next we have zstyle lines, that write to the `vcs_info_msg_0_` and
`vcs_info_msg_1_` variables, which we'll assign to PROMPT and
RPROMPT, like so:

PROMPT='${vcs_info_msg_0_}'
RPROMPT='${vcs_info_msg_1_}'

PROMPT = regular prompt
RPROMPT = right prompt

There three different prompt scenarios we'll consider, each have a
label.  

|---------------+-------------------------------------------------------------|
| label         | meaning                                                     |
|---------------+-------------------------------------------------------------|
| formats       | when we are in a git repository folder                      |
| nvcsformat    | when we are not in a git repo folder                        |
| actionformats | when we have a pending git action like merge, rebase, etc.. |
|---------------+-------------------------------------------------------------|


The following works on the `formats` prompt:

```
zstyle ':vcs_info:git*' formats "%s  %r/%S %b %m%u%c "
```

|----+------------------------------------------------------------|
| %s | The current version control system, like git or svn.       |
| %r | The name of the root directory of the repository           |
| %S | The current path relative to the repository root directory |
| %b | Branch information, like master                            |
| %m | In case of Git, show information about stashes             |
| %u | Show unstaged changes in the repository                    |
| %c | Show staged changes in the repository                      |
| %a | ‘actions’ i.e.: currently performing a merge or rebase     |
|----+------------------------------------------------------------|

`check-for-changes` is disabled by default because it might slow
things down, it tell the back-end to check for working-copy changes
and staged changes, so you can use the %c and %u sequences. Enable it
with:

```
zstyle ':vcs_info:*' check-for-changes true 
```

So here is a full example:

```
autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git
precmd() {
    vcs_info
}
 
setopt prompt_subst
zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:*'    formats "%f[%%n@%%m %1~] $ " "%f%a %F{3}%m%u%c %f%b:%r/%S" 
zstyle ':vcs_info:*'    nvcsformats   "%f[%n@%m %1~]$ " ""
zstyle ':vcs_info:*'    actionformats '%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f '

PROMPT='${vcs_info_msg_0_}'
RPROMPT='${vcs_info_msg_1_}'
```

* arrays

+ initialize 

    % myarr=(2 4 3)  

+ access, index

 Access starts from 1 not 0

    % echo $myarr[2]
    4

+ access: negative index

    % echo $myarr[-1]
    3

+ delete element

    % myarr[2]=()
    % print $myarr
    2 3

+ loop over array

    myarray=(1 2 3 4 7)
    for i in $myarray
    do
      print $i
    done

* hashes

    % typeset -A hash
    % hash=(wife emily)
    % print $hash
    emily
    % print $hash[wife]
    james

+ add element

    % hash[child]=kevin
    % print $hash
    emily kevin
    % print $hash[child]
    kevin

+ remove elements

    % unset "hash[child]"
    % print $hash
    emily
* arithmatic
a=1
b=1
((c=a+b))
* zparseopts

reference:
http://lavica.fesb.hr/cgi-bin/info2html?(zsh)The%20zsh/zutil%20Module

** option

*** using -a flag

look for a single `-f` flag passed to script.  If found put into
array called: `my_options_array`.

test.sh:

    zparseopts -a my_options_array f
    echo $my_options_array[1]

output:

    % ./test.sh -f
    -f

*** appending array to option

You can achieve exactly the same effect like so:

    zparseopts f=my_options_array

so instead of passing an `-a` flag to specify where the param should
be stored, the array is appended to the option.

** option with required value

We add a single colon `:` after the required parameter name.

test.sh:

    zparseopts -a my_options_array f:
    echo $my_options_array[1]
    echo $my_options_array[2]

output

    % ./test.sh -f abc
    -f
    abc
    % ./test.sh -f
    ./test.sh:zparseopts:4: missing argument for option: f

** a longname option

We can take an options like: `--file abc.txt` instead of just `-f
abc` by preceeding the option with a `-`

test.sh:

    zparseopts -a my_options_array -file
    echo $my_options_array[1]

output:

    % ./test.sh --file
    --file

** skip (dont stop at) unknown options

Normally processing stops when we encounter an option we didn't tell
`zparseopts` about.  

    zparseopts -a a_option a
    echo $a_option[1]

output:

    % ./test.sh -b -a
     
    ~ % ./test.sh -a -b
    -a

However we can use the -E flag to carry on processing all the
arguments:

test.sh:

    zparseopts -E -a a_option a
    echo $a_option[1]

output:

    % ./test.sh -b -a
    -a

** per option array

We can put each option into a named array.  So the following line:

test.sh:

    zparseopts a=a_opt b=b_opt
    echo $a_opt[1]
    echo $b_opt[1]

output:

    % ./test.sh -a -b
    -a
    -b

This is helpful for the next use case:

** a long AND short option

Maybe we want an option to be specified at either `-f` or `--file`

Here we check the length of the array with the `$#` notation.  So
`$#file_option` is the length of the `file_option` array.

test.sh:

#+BEGIN_SRC SH

    zparseopts f=file_option -file=file_option
    if [[ $#file_option -ge 1 ]]; then
      echo "either an -f or an --file option was used"
    fi

#+END_SRC

output:

     ./test.sh --file
    ither an -f or an --file option was used
     ./test.sh -f
    ither an -f or an --file option was used
     ./test.sh -f --file
    ither an -f or an --file option was used
     ./test.sh
                     
** Other notes

*** Hash instead of array.

a hash or associative array can be used in place of an array.

    zparseopts -A my_opt_hash a:b:c:

The keys of the hash will be the options, the values will be the
option if it doesn't have a required value, or the value if it does. 


*** Optional values to options

if you want to be able to do:

    test.sh -f

or

    test.sh -f fenton.txt

you use double colon, as in:

    zparseopts -a my_opts f::





























looks for a parameter 

$foo = -a    

-D = Remove the parameter for the options list after it is processed
-E = Keep parsing options even if you run into one that isn't asked
for (specified/known) in your script
-A = put args into an Associative/Hash.  Key is argument name, value
is what was passed in.
* output shell script usage string

usage() {
  cat <<EOF

specify one of -u (install to USB) or -c (install to computer), not
both or neither :)

specify device with -d <device>.  For example: `-d /dev/sdb`.
EOF
}
* functions

** Simple

Define function called `fenton` that prints "hello".

```
# Define function first
fenton() {
  echo "hello"
}
# Call function
fenton
```

outputs: "hello"

** Function with parameter

Function dont have named parameter but instead use `$1`, `$2`,
etc... as default names for parameters passed to function.

Here we have a function that takes a name too.

```
fenton() {
  echo "hello $1" 
}
# Call function
fenton "fenton"
```

outputs: "hello fenton"
